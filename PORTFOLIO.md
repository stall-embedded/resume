# Portfolio of [KH](https://stall-embedded.github.io/)

## 1. Outline
### 1.1. Profile
이름: 김규형

  - 생년월일: 1998-04-14
  - 연락처: 010-6634-6083
  - e-mail: kviw0220@gmail.com
  - Github: https://github.com/stall-embedded

### 1.2. Educations
아주대학교 대학원, 2022-03 ~ 2024-02
  - 전공: 지식정보공학

아주대학교, 2017-03 ~ 2022-02
  - 전공: 전자공학

경기북과학고등학교, 2014-03 ~ 2017-02

### 1.3. Awards
  - 제2회 한국 인공지능 학술대회 장려상
  - 대한전자공학회 학술대회 참가
  - 한국통신학회 학술대회 참가 및 포스터 섹션 발표

### 1.4. Skills
Skill        | Note
-------------|-----------------------------------
C            | 임베디드, 최적화
Matlab       | 신호 분석
Python       | 머신러닝, 신호처리, 시각화 시 사용
Cube MX      | STM 임베디드 용 SDK
VS Code      | 대부분 프로그래밍 시 사용
Arduino      | 임베디드 테스트 시 사용
ML, DL       | 데이터 분석
C#           | Unity 개발시 사용
JS           | API로부터 데이터 가져올 때 사용
Go           | 간단하게 사용가능
Shell Script | 간단하게 사용가능
Android      | 핸드폰에서 데이터 추출할 때 사용

### 1.5. Experiences
17살에 프로그래밍에 입문한 뒤, 10년을 쉬지 않고 꾸준히 개발에 매진해 왔습니다. 대학교 4학년부터 랩실에 들어가 대학원에 진학하며 실제 기업들과 협력하며 산업용 프로젝트를 3년간 진행해왔습니다.

  - 프로그래밍 경험: 10년
  - 산업용 프로그래밍 경험: 3년

Team                             | Entry Date | Leave Date
---------------------------------|------------|------------
Lifecare Lab                     | 2021-01    | 2024-02


## 2. Introduction
### 2.1. For a lifetime
프로그래밍을 시작하게 된 계기는, 학교에서 백준 온라인 저지를 따라해서 GBS 저지라는 홈페이지를 선생님께서 만들어 주셨습니다. 친구들과 서로 문제를 풀며 경쟁하는 과정이 게임같고 재미있어서 프로그래밍에 빠지게 되었습니다.

단순하기 짝이없는 프로그래밍 문제들이였지만 홈페이지가 발전하며 점점 더 어려운 문제들이 수록되었고 해당 문제들에 대해서 도전하였습니다. 풀리지 않는 문제들에 대해서는 하루종일 고민하였고 야자시간에 컴퓨터실을 빌려서 그 문제를 해결하기 위해서 코드를 이리저리 수정하고 알고리즘을 생각해보며 프로그래밍 실력을 키워왔습니다. 그렇게 풀리지 않던 문제를 풀고 조금 더 빠르게 풀 수 없을지, 조금 더 코드를 단순화 시킬 수 없는지 보며 코드를 수정하였습니다.

프로그래밍에 흥미가 생긴 뒤 방과후 수업으로 아두이노를 듣게 되었고 그날로 임베디드에 빠지게 되었습니다. 단순히 수학적인 알고리즘을 세우는데 만족하는 것이 아니라 현실세계에 영향을 미치는 프로그램을 만든다는 사실이 공학적인 감성을 깨워주었고 이를 활용할 수 있는 길이 열리는 것을 보았습니다.

임베디드에 대해 조금 더 공부하기 위하여 전자공학과에 진학하였고 하드웨어에 대한 이해도와 소프트웨어에 대한 이해도를 동시에 올리는 것을 목표로 학습하였습니다. 전자공학과에 와서도 소프트웨어에 대한 열정을 그대로 남아있기에 소프트웨어 관련 과목들은 항상 A이상으로 유지하려 노력하였습니다. 전자공학적인 지식은 프로그램을 작성할 때 하드웨어에 사양에 따라 최적화를 할 수 있음을 알게 해주었고 이는 임베디드 개발자가 되기에 더없이 중요한 지식임을 깨달았습니다.

임베디드를 배우며 가장 인상깊었던 것은 현실의 아날로그 데이터를 받아온 후 분석하여 어떠한 형태로든 피드백을 주는 것이였습니다. 4학년때 교수님과 컨택하며 기업과 연계 프로젝트를 진행하였는데, 이때 여태까지 쌓아올린 것들이 산업에서도 사용될 수 있다는 사실이 기쁘게 만들었고 단순한 이론이 현실에 적용되는 순간 공부를 한 이유을 알게되었고 이는 아주 큰 카타르시스를 제공하였습니다.

대학원에 진학하며 여러가지 기업과 협력하며 산업프로젝트를 진행하였고 받아온 데이터를 분석하기 위해 AI가 필요함을 느꼈습니다. 단순히 DSP로 분석하기에는 힘든 부분들이 많았기에 AI를 활용하여 더 나은 피드백을 제공하게 되었습니다. 이때부터 AI에 관심이 생겨 공부를 하며, 기업과 함께 AI를 사용한 프로젝트를 진행했습니다.

AI에 대한 관심도와 능력을 키우며 학위논문을 써야할 시기가 다가왔을 때, 내가 잘할 수 있는 것을 주제로 논문을 써보자 정했습니다. 여태껏 학습해왔던 임베디드와 AI 두 분야 모두 관련이 있는 주제가 없나 찾아보았습니다. 그러던 중, 뉴로모픽 DNN기술인 SNN을 발견하게 되었고 SNN은 전력사용량이 줄고, 실제 뇌와 비슷하게 운영되기에 앞으로 AI, 임베디드 시장 모두에 충분히 활용 가능할것이라 생각되었습니다. 따라서 이를 공부하며 SNN을 활용하여 학위 논문을 작성하게 되었습니다. 이렇게 여러가지를 학습하며 Full dive VR이라는 꿈을 향해 달려가고 있습니다.

### 2.2. Career Goals
프로그래밍을 시작하고 계속해서 능력을 키워왔던 이유는 꿈을 향해 달리기 위해서입니다. 중학생 시절 보았던 소설, 애니메이션에서 완전 몰입형 가상현실(Full dive VR)이라는 세계를 보았습니다. 그 내용은 소년의 마음에 불을 지폈고 그대로 꿈이 되어주었습니다.

처음 시작은 단순히 그 세상을 만들고 즐기고 싶었지만, 머리가 커지며 완전 몰입형 가상현실이 가져올 수 있는 다른 변화들에 대해서도 생각하게 되었습니다. 먼저, 완전 몰입형 가상현실이라는 것은 뇌파를 통해서 가상속의 아바타를 조종할 수 있어야 합니다. 따라서 이는 뇌파를 통해서 의수, 의족 등을 제어할 수 있다는 뜻입니다. 이는 현재 BCI분야에서 연구되고 있습니다. 하지만 안타깝게 한국에서는 해당 분야를 연구하는 기업들은 없습니다. 하지만, 그와 비슷하게 데이터를 활용하는 기업들은 많습니다. 기업에 들어가 실무에서 더욱 더 다양한 데이터들을 다루고 그것들을 분석하며 꿈에 한 발자국 더 다가가고 싶습니다.


## 3. Educational Projects
### 3.1. Comparative study on the robustness of CNN and SNN against adversarial attacks of image data modification
- Github : https://github.com/stall-embedded/Research
- Thesis : https://www.riss.kr/search/detail/DetailView.do?p_mat_type=be54d9b8bc7cdb09&control_no=806b135319a6d20fffe0bdc3ef48d419&keyword=%EA%B9%80%EA%B7%9C%ED%98%95%20%EC%A1%B0%EC%9C%84%EB%8D%95

이 연구는 Convolutional Neural Networks (CNN)와 Spiking Neural Networks (SNN)의 적대적 공격에 대한 성능을 비교함으로써 CNN을 SNN이 대체할 수 있는지에 대하여 연구한 내용입니다.
연구의 첫 내용은 CNN과 SNN의 CIFAR10 데이터 셋에 대한 분류 성능을 비교합니다. 테스트한 CNN 모델은 88%의 정확도를 가지고 있습니다. 같은 형식의 모델을 가진 SNN은 82%의 정확도를 보였습니다. 이는 SNN에 대해 연구가 초기 진행상태이기 때문이며, 추후 더 정확한 학습 방법이 발견된다면, 이에 대한 정확도를 향상시킬 수 있을 것으로 생각됩니다. 그렇다면 CNN을 SNN으로 대체하는 것이 가능합니다.

두 번째 주요 내용은 Fast Gradient Sign Method (FGSM), Projected Gradient Descent (PGD), Carlini & Wagner (C&W), DeepFool의 적대적 공격 시나리오를 이용하여 CNN과 SNN의 강건성을 비교하였습니다. 전체적으로 SNN이 CNN에 비해 강인한 결과가 나왔습니다. 그중 특별히 반복적인 공격에 대해 CNN에 비해 SNN이 강건함을 보였습니다. 이는 SNN이 미세한 변화에 민감하게 반응하고 복잡한 공격에 대해 내성을 가질 수 있음을 보여줍니다. 하지만, DeepFool공격의 낮은 반복 횟수에 대해서는 CNN이 더 강건함을 보였으므로 이는 추후 연구대상으로 삼았습니다.

세 번째 주요 내용은 Gradient-weighted class Activation Mapping (Grad-CAM)과 Spiking Activation Mapping (SAM)을 통한 분석입니다. 단순히 적대적 공격을 받은 이미지을 가지고 모델의 분류 정확도를 비교하는 것은 강건성에 대한 심도있는 이해를 제공하지 않습니다. 따라서 eXplainable Artificial Intelligence (XAI)기법인 Grad-CAM과 SAM을 사용하여 각각 CNN, SNN이 모델을 분류할 때 어느곳을 중점적으로 보는지에 대하여 확인하였습니다. 결론적으로 모델의 시각적 분석은 SNN이 CNN에 비해 확실히 우세함을 보였습니다. 이 말은, 강한 강도의 변형에도 SNN은 이미지를 분류하는데 있어서 중요한 부분을 캐치해내는 능력이 뛰어남을 입증합니다. 따라서 강건성 측면에 있어서 CNN에 비하여 SNN이 가지는 메리트가 큰 것을 확인하였습니다.

![image](https://github.com/stall-embedded/stall-embedded.github.io/assets/78913541/b3d110ca-41e3-4410-bd23-ff1edef9b53b)
![image](https://github.com/stall-embedded/stall-embedded.github.io/assets/78913541/f05a8fd8-5eec-40be-89b7-af4de66e9a0a)

왼쪽 이미지는 FGSM공격에 대한 CNN 모델의 반응을 Grad-CAM을 통하여 분석한 결과이고, 오른쪽 이미지는 FGSM공격에 대한 SNN 모델의 반응을 SAM을 통하여 분석한 결과입니다. CNN, SNN 둘 다 변형되기 전 original 이미지에 대하여 판별하는 부분이 고양이의 얼굴 부분임을 확인할 수 있습니다. FGSM공격의 계수가 커질수록 CNN은 고양이의 얼굴을 중점적으로 보는것이 아니라 다른 부분을 보는 것을 확인할 수 있고 SNN의 경우는 계속 고양이의 얼굴을 중점적으로 보는 것을 확인할 수 있습니다.

### 3.2. Gradient boosting Classifier와 Feature importance를 이용한 EEG신호처리에 따른 Hyponogram 예측 모델에 관한 연구
- Paper : https://manuscriptlink-society-file.s3-ap-northeast-1.amazonaws.com/kics/conference/koreaai2021/presentation/D-4-2.pdf

![image](https://github.com/stall-embedded/stall-embedded.github.io/assets/78913541/0988efa8-8e9f-4ae0-9295-534fad6f8447)

이 연구는 뇌파(EEG) 데이터를 사용하여 수면의 깊이를 예측하는 모델을 개발한 내용입니다. 2-channel의 EEG 데이터를 분석하여, 수면 상태를 나타내는 Hyponogram의 다양한 단계(위 사진; Wake, 렘수면 상태, 비렘수면 상태 등)를 예측하였습니다. 이 연구에서는 Gradient Boosting Classifier 알고리즘을 이용하여, 뇌파의 주파수 대역에 따라 분류한 여러 feature들을 기반으로 머신러닝을 수행하였으며, 각 feature의 중요도를 분석하였습니다. 

![image](https://github.com/stall-embedded/stall-embedded.github.io/assets/78913541/d46c79e6-3336-4574-9a28-90e4a868d91a)

신호처리 방법(예: FFT, Welch PSD)에 따른 예측 모델의 성능 비교를 통해, 특정 신호처리 방법이 수면 상태 예측에 더 유효함을 보여주었습니다. 특히, FFT와 Welch PSD의 창함수를 변경한 feature을 가지고 뇌파 분석에 대한 각각의 feature importance를 분석하여, 뇌파별 수면 상태 예측에 중요한 요소들을 식별하였습니다.

### 3.3. EEG signal classification based on emotion analyzed by XAI
- Github : https://github.com/stall-embedded/recog-EEG

- Dataset : https://www.kaggle.com/datasets/birdy654/eeg-brainwave-dataset-feeling-emotions

위 데이터 셋을 사용하여 EEG 분류 모델을 만들고 XAI를 이용하여 분류 기준을 파악하였습니다. 데이터 셋은 영화의 내용이 positive, neutral, negative일 때, 그 영화를 시청하는 실험자의 뇌파를 뽑고 여러가지 신호처리를 한 결과입니다. 신호처리를 한 결과들이 feature가 되고 이를 사용해서 positive, neutral, nagetive 세개의 클래스로 구분하는 단순한 분류모델을 만들었습니다.


SVM HyperParameter  | value
--------------------|------------
Max iteration       | 5000
C                   | 0.005
penalty             | L1
dual                | False

(C : 정규화 파라미터)


Random Forest HyperParameter  | value
------------------------------|---------
Max depth                     | 5
Min samples leaf              | 10

(Min samples leaf : 하나의 리프 노드에 필요한 최소 샘플 수)


XGBoost HyperParameter         | value
-------------------------------|-------
Max depth                      | 3
Learning rate                  | 0.1
N estimators                   | 20
subsample                      | 0.4
L1 regularization coefficient  | 0.1
L2 regularization coefficient  | 10.0

(N estimators : 앙상블에 사용되는 트리 수
subsample : 각 트리별 학습할 데이터의 비율)

- 정확도 : ![image](https://github.com/stall-embedded/stall-embedded.github.io/assets/78913541/1d40bd3f-b4f9-4c6d-9f0e-44ae67e8a4c3)

분류 모델은 SVM, Random Forest, XGBoost 세 가지에 대하여 실험하였습니다. SVM, XGBoost 모두 규제를 사용하였고 세 모델 모두 hyperparameter를 수정하며 가장 높은 정확도를 달성한 수치를 사용하였습니다. XAI를 사용하여 분석한 결과는 아래와 같습니다. Individual conditional expectation(ICE), Local Interpretable Model-agnostic Explanation(LIME)를 분석하여 클래스 분류시 중요한 클래스들이 어떻게 되는지 확인하였습니다. 

#### ICE
- SVM
  
![image](https://github.com/stall-embedded/stall-embedded.github.io/assets/78913541/a640fc2c-0585-458c-b277-fbf3e3cebcc7)
Feature들의 값이 증가할 때 Negative이며, 감소할 때 Neutral과 Positive인 것을 확인할 수 있고 Positive는 Neutral에 비해 판단이 어려운 것을 확인 가능합니다.

- RandomForest

![image](https://github.com/stall-embedded/stall-embedded.github.io/assets/78913541/f0fd161f-af12-4d17-85b9-d800bed1031d)
Feature들의 값이 증가하면 Negative일 확률이 줄어들고, Neutral일 확률이 증가, Positive일 확률이 증가합니다. 여전히 Positive는 Neutral에 비해 판단이 어려운 것을 확인 가능합니다. 하지만 feature의 값이 증가함에 따라서 Positive일 확률이 증가한다는 것은 증가하는 feature의 개수가 더 많기에 확인 가능합니다.

- XGBoost

![image](https://github.com/stall-embedded/stall-embedded.github.io/assets/78913541/aef46326-d8a4-471d-a8ed-d49dbb1b3c66)
Feature들의 값이 증가하면 Negative일 확률이 줄어들고, Neutral일 확률이 증가, Positive일 확률이 감소합니다.

#### LIME
- SVM
  
![image](https://github.com/stall-embedded/stall-embedded.github.io/assets/78913541/959ba829-dcb8-48b6-86e8-72532b095505)
Negative와 Neutral이 mean_0_b에 의해서 구분이 가능하다고 보여집니다. Positive또한 mean_0_b의 영향을 받습니다. (mean_0_b는 b번째 실험자의 0번째 실험 평균값입니다.)

- RandomForest

![image](https://github.com/stall-embedded/stall-embedded.github.io/assets/78913541/7c7f1406-932f-4219-b06a-e4debb6684ac)
뚜렷하게 관여하는 feature는 없고 여러 feature들이 동시에 판단을 돕습니다. 여기서 특이하게 Positive는 SVM과 동일한 Feature가 가장 크게 관여한다는 것을 알 수 있습니다.

- XGBoost

![image](https://github.com/stall-embedded/stall-embedded.github.io/assets/78913541/1800f16a-677b-4e23-b9c6-a108110747bd)
가장 중요하게 봐야 할 것이 mean_0_b입니다. SVM에서 중요한 feature가 여전히 관여하는 것을 볼 수 있습니다. Negative를 보시면 mean_2_b, mean_0_a등 EEG의 평균이라는 것이 감정에 크게 관여한다는 것을 볼 수 있습니다.

결록적으로 ICE를 통해 분석했을 때 SVM보다 두 앙상블 모델의 정확도가 높은 이유가 feature의 경향성이 뚜렷하기 때문임을 확인하였습니다. Mean 값이 감정 분류에 큰 영향을 미친다는 것을 확인하였습니다. 평균을 취하게 되면 Moving Average Filter처럼 작용하게 되어 노이즈가 어느정도 제거되기에 큰 영향이 있는 것으로 보입니다.

### 3.4. MNIST discrimination AI optimization
Github : https://github.com/stall-embedded/Handwritten-Digit-Recognition-Code-Optimization-

한백전자의 SM10 임베디드 시스템 보드위에 미리 학습된 MNIST분류 CNN을 가지고 실행 시간을 단축시키는 프로젝트를 진행하였습니다. AndroX Studio와 Eclipse를 사용하여 프로그래밍을 하였습니다. 사용된 최적화 기법으로는 GCC Optimazation Options, Vector Floating Point(VFP), Loop Unrolling, Neon(ARM에서 개발한 64/128bit 복합 SIMD아키텍처)을 사용하였습니다.

#### GCC Optimazation Options

![image](https://github.com/stall-embedded/stall-embedded.github.io/assets/78913541/bf78e06c-6e40-4a2b-91cd-f118f9e00ce2)

붉은 색 네모칸을 O1, Os, O2, O3로 변경하며 실행시간을 측정하였습니다.

Option | AverageExecution time(sec)
-------|---------------
O1     |40.385
Os     |40.063
O2     |39.385
O3     |39.408

가장 Execution time이 낮은 O2 최적화를 사용하였습니다.

#### VFP

![image](https://github.com/stall-embedded/stall-embedded.github.io/assets/78913541/d648f46c-86f0-4f9d-a233-bcba9ae47c26)

CNN에서 이미지를 처리 할 때, 부동소수점 연산이 굉장히 오래 걸리기 때문에 ARM에서 제공하는 VFP를 사용하여 부동소수점 연산을 빠르게 실행하였습니다. 
Execution time : 5.500s으로 단순히 O2를 사용하여 최적화한 결과보다 86%가량 최적화가 되는 것을 확인할 수 있었습니다.

#### Loop Unrolling
for문에 Loop Unrolling의 배율을 조정하며 실험했을 때, 4배율이 가장 최적임을 확인하였습니다. 따라서 SM10은 병렬처리 시, 4배율의 Loop Unrolling의 효율이 가장 좋은 것을 확인하였습니다.

Magnification | AverageExecution time(sec)
---------|---------------
x2       |5.252
x4       |5.071
x8       |5.487

또한 for문의 iterator를 0과 비교하게 바꾸어 성능 향상이 일어난 것을 확인하였습니다.
위와 같은 작업을 수행한 후 Execution time이 4.750s로 줄어들었습니다.

#### Neon

![image](https://github.com/stall-embedded/stall-embedded.github.io/assets/78913541/7f9135fa-9650-413a-9829-78c1a4c261e1)
![image](https://github.com/stall-embedded/stall-embedded.github.io/assets/78913541/fe70470d-fc88-4cb8-8ee7-cbb4b7f8c410)

Neon의 적용을 위해 makefile에 -mfpu=neon을 추가하였습니다. 또한 main코드에 Neon함수 사용을 위해 arm_neon.h 라이브러리를 추가하였습니다.
계산 방식을 Neon을 사용하는 방식으로 바꾸었습니다.

![image](https://github.com/stall-embedded/stall-embedded.github.io/assets/78913541/ce2a1721-03ff-4287-b30a-d4ac38311a91)

Execution time이 4.339s으로 감소하였습니다.


- 결론

![image](https://github.com/stall-embedded/stall-embedded.github.io/assets/78913541/a375048a-4b8c-4947-9142-f6d3df1990ee)

최적화를 시행한 결과 57.044sec -> 4.339sec으로 최적화를 수행하였습니다. 결과적으로 평균 92.4%의 최적화가 수행되었습니다.

### 3.5. Make Overwatch VR controller
- Youtube : https://www.youtube.com/watch?v=LrcyZ_7xOWY&t=126s

![image](https://github.com/stall-embedded/stall-embedded.github.io/assets/78913541/04828f10-3a18-4cc1-8b2a-1752ae997e59)

![image](https://github.com/stall-embedded/stall-embedded.github.io/assets/78913541/33b57e84-a08f-475e-b676-7fb4e70ae73e)

![image](https://github.com/stall-embedded/stall-embedded.github.io/assets/78913541/a03aa092-da09-4ab2-a23b-a23e8d7e131f)


고등학교 시절 Overwatch라는 게임을 VR로 해보고 싶어서 방과후 과목으로 수강하였던 아두이노와 센서들을 가지고 VR로 플레이할 수 있게 컨트롤러를 구현하였습니다. 통신방법은 zigbee, serial을 사용하였고 이를 통하여 2개의 아두이노, 센서들이 서로 상호작용하게 제작하였습니다.

### 3.6. Make Dapp about Poker by Unity
- Github : https://github.com/stall-embedded/poker_unity

블록체인 수업 중, 블록체인 서버와 통신하는 Dapp을 제작하였습니다. 총 2인 프로젝트로 제 담당은 Dapp, 나머지 팀원의 담당은 블록체인 서버 구현이였습니다. 사용자의 모든 정보는 블록체인 서버에 저장되고 따로 Dapp 서버가 존재하여 Dapp에서 HyperLeger 블록체인 서버에 저장되어 있는 정보를 가져오고 동시에 보낼 수 있는 Dapp을 개발하였습니다.

![image](https://github.com/stall-embedded/stall-embedded.github.io/assets/78913541/aeff61b9-f0bb-4695-923d-cfecfe34691c)

개발한 Dapp은 2인용 포커게임으로써, Unity, RPC를 통해 동기화를 구현한 온라인 게임입니다. 해당 게임은 회원가입 기능을 통해 블록체인 서버에 아이디 패스워드를 보내게 됩니다. 로그인 기능은 블록체인 서버에서 인증을 받아서 하게 됩니다. 게임머니, 게임의 승패 모두 블록체인 서버에 기록되게 됩니다.

Dapp의 구조는 아래와 같습니다.

+ 먼저 카드의 데이터를 받아오고 동기화 시키는 부분입니다.
![image](https://github.com/stall-embedded/stall-embedded.github.io/assets/78913541/1f5ae1d9-fd63-45ee-80fe-109782de3f8e)

+ rpc를 통해 동기화되는 목록들입니다.
![image](https://github.com/stall-embedded/stall-embedded.github.io/assets/78913541/66a6051b-447f-48cf-857b-227148d5e810)

+ 로그인, 회원가입이 메인 블록체인 서버와 통신하는 방법입니다.
![image](https://github.com/stall-embedded/stall-embedded.github.io/assets/78913541/1cd34171-392a-42ed-8e41-4acfb9e8cc31)

+ 메인 블록체인 서버와 지갑의 데이터를 통신하는 방법입니다.
![image](https://github.com/stall-embedded/stall-embedded.github.io/assets/78913541/c8245ebc-33e2-4180-bd87-e3b26c04f922)

+ 승패의 결과와 배팅금을 통해 지갑의 데이터를 변경하기 위해 메인 블록체인 서버와 통신하는 부분입니다.
![image](https://github.com/stall-embedded/stall-embedded.github.io/assets/78913541/3f8a90e3-eb37-481a-aca7-0de746ff0c52)


## 4. Commercial Projects
### 4.1. Improved OCR for MSDS analysis
기업과 협력하여 진행한 프로젝트이기에 소스코드를 오픈할 수 없습니다.
- Paper : https://www.dbpia.co.kr/journal/articleDetail?nodeId=NODE11487389
- Product : https://scist.co.kr/shop.php?goPage=GoodDetail&g_code=20230906100743610&cat_no=103&offset=

Material Safety Data Sheet(MSDS)에서 문자들을 OCR을 통해 인식하는 프로젝트를 진행하였습니다. 화학물질/제품에서 가장 중요한 CAS, 영문물질명, 물질함량, 예방코드, 위험코드등을 DB에 저장하기 위해서 인식 후, MQTT를 통하여 전송하는 프로그램을 작성했습니다. 

![image](https://github.com/stall-embedded/stall-embedded.github.io/assets/78913541/8cf39385-a9cb-4321-92f1-338527b68dbc)

위의 이미지는 MSDS를 OCR로 인식한것입니다. 아래 이미지는 해당 인식 결과를 DB에 저장하기 쉽게 json형태로 바꾼 것입니다.

![image](https://github.com/stall-embedded/stall-embedded.github.io/assets/78913541/a56b6573-0826-4834-b2af-eaab7a0ab4af)

이미지 OCR 인식중 원하는대로 인식이 되지 않는 경우들이 발생하게 됩니다. 이런 경우를 모두 다 예외처리를 할 수 없기 때문에, 예외처리가 곤란한 경우에는 일반적으로 처리할 수 있게 데이터에 전처리를 하게 됩니다. 아래는 그 예시입니다. 아래 이미지는 인식 순서에 오류가 생기는 경우가 발생한 것입니다. “product name”이라는 단어를 인식 후, “Celite”라는 제품명을 인식해야 하는데, 위의 경우는 제품명 먼저 인식하는 문제가 발생하였습니다.

![image](https://github.com/stall-embedded/stall-embedded.github.io/assets/78913541/da7f68a6-e708-4ac1-b7b4-db62ba27354f)

이를 해결하기 위하여 다음과 같은 알고리즘을 설계하여 해결하였습니다.
-	OCR의 우선순위는 위쪽, 왼쪽이 아랫쪽, 오른쪽보다 높습니다. 따라서 회전변환을 사용하여 시계방향으로 회전시킨다면, 무조건 왼쪽에 있는 텍스트가 먼저 인식이 됩니다. 하지만 너무 기울일 경우 인식 자체에 문제가 발생할 수 있기 때문에 적당한 회전각도를 찾아야 합니다. 0 ~ 3도 사이를 0.1 ~ 0.2도씩 쪼개어 비교를 해보았을 때, 1도가 가장 적절하게 인식하는 구간인 것을 찾을 수 있었습니다.
  
-	추가로 인식률 향상을 위해 엣지의 선명도를 높이는 방법으로 기존 컬러 이미지를 흑백 이미지로 바꾸어서 OCR프로그램을 작동시켰습니다. 아래 이미지는 회전변환, 흑백변경이 적용된 이미지입니다.

![image](https://github.com/stall-embedded/stall-embedded.github.io/assets/78913541/64de95a0-04f4-4bc5-ba25-6977d92419d3)

CAS, 예방, 위험 코드같은 경우는 글자가 이어져서 인식되지 않고, + 혹은 - 를 기준으로 잘려서 인식하는 경우가 발생합니다. 따라서 이를 해결하기 위하여 데이터 인식 후 후처리를 진행하였습니다.

### 4.2. Golf swing analysis
- Paper : https://www.dbpia.co.kr/journal/articleDetail?nodeId=NODE11487386

갤럭시 워치 4를 기반으로 Acceleration, Gyro, Magnitude 데이터를 가지고 골프 스윙시 그 궤적을 추출하고, 그 궤적위에 골프스윙시 중요한 포인트들을 표시하는 프로그램입니다. 단순히 Acceleration 데이터를 적분 시키면, 적분 오차가 발생하기 때문에 Gyro, Magnitude 데이터를 포함하여 그 값을 보정해야 했습니다. 해당 값들을 가지고 Altitude and Heading Reference System(AHRS)라는 항공기 자세측정 기술을 사용하여 궤적을 추출해냈습니다.

궤적, Accelration, Velocity 데이터를 가지고 골프스윙시, 해당 스윙이 얼마나 좋은 스윙인지 판단하기 위하여 포인트 및 여러 데이터들을 추출해냈습니다. 먼저 스윙 시작 지점, 백스윙 최고점, 골프채와 공이 닿는 타격점, 공을 친 후 계속 자세를 유지하는 지점 이렇게 총 4개의 지점을 구했고, 해당 지점 사이 평균속력, 백스윙과 다운스윙 궤적의 차이 정도 등을 계산하여 스윙 평가에 필요한 데이터들을 얻어내는 프로젝트를 수행하였습니다.

![image](https://github.com/stall-embedded/stall-embedded.github.io/assets/78913541/4b98157f-682f-4991-ad91-4682cf78d7bc)

원하는대로 얻고자 하는 궤적 및 파라미터들을 얻을 수 있었습니다.

### 4.3. Smart Mask
- Paper : https://www.dbpia.co.kr/journal/articleDetail?nodeId=NODE11132595
- Product : https://gthelema.com/

![image](https://github.com/stall-embedded/stall-embedded.github.io/assets/78913541/d6eeab6c-c220-4498-a5ac-0a9e64ab77a1)

스마트 마스크에 부착된 소리 센서로부터 데이터를 받아온 후 개발시 로그 분석은 UART를 사용하여, 실제 사용시에는 BLE를 통하여 호흡, 코골이, 무호흡을 구분하여 사용자에게 피드백을 주고, 가속도 센서를 통하여 수면중 뒤척임을 감지하여 수면의 질을 분석하는 프로젝트입니다.

![image](https://github.com/stall-embedded/stall-embedded.github.io/assets/78913541/c62ac309-87d2-4b1d-b61b-3789485191ad)
호흡과 코골이의 크기가 같기 때문에 DSP기술을 이용하여 데이터를 수정한 뒤, 호흡과 코골이를 구분하는 프로그램을 작성하였습니다.

![image](https://github.com/stall-embedded/stall-embedded.github.io/assets/78913541/f40a2217-971d-44b4-8976-794edd154622)
시나리오 상 호흡, 코골이, 무호흡이 혼재 되어있고 그 크기들이 다 다를때, 적응형으로 Threshold를 조정하며 호흡, 코골이, 무호흡을 성공적으로 구분할 수 있게 여러 시행착오를 겪으며 프로젝트를 진행하였습니다.

![image](https://github.com/stall-embedded/stall-embedded.github.io/assets/78913541/5d4b3d8d-de7e-43bc-88f2-9adfc3b88337)
또한, 가속도 센서의 움직임을 분석하여 사용자의 뒤척임을 감지할 수 있게 제작하였습니다.
